<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aina</title>
<style>
* { 
  box-sizing: border-box; 
  margin: 0; 
  padding: 0; 
}

html, body {
  height: 100%; 
  width: 100%;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #000;
  color: #fff;
  overflow: hidden;
}

/* Header */
.header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 60px;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(20px);
  border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.header h1 {
  font-size: 17px;
  font-weight: 600;
  color: #fff;
}

/* Mode Pills */
.mode-selector {
  position: fixed;
  top: 70px;
  left: 0;
  right: 0;
  height: 50px;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 99;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(10px);
}

.mode-pills {
  display: flex;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 20px;
  padding: 2px;
}

.mode-pill {
  padding: 8px 16px;
  border-radius: 18px;
  border: none;
  background: transparent;
  color: rgba(255, 255, 255, 0.6);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.mode-pill.active {
  background: rgba(255, 255, 255, 0.2);
  color: #fff;
}

/* Chat Container */
.chat-container {
  position: fixed;
  top: 120px;
  bottom: 90px;
  left: 0;
  right: 0;
  overflow-y: auto;
  padding: 0 16px;
  scroll-behavior: smooth;
}

/* Welcome */
.welcome {
  text-align: center;
  padding: 40px 20px;
  color: rgba(255, 255, 255, 0.6);
}

.welcome h2 {
  font-size: 20px;
  font-weight: 600;
  margin-bottom: 8px;
  color: #fff;
}

.welcome p {
  font-size: 16px;
  line-height: 1.4;
}

/* Messages */
.message {
  display: flex;
  margin-bottom: 12px;
  max-width: 100%;
}

.message.user {
  justify-content: flex-end;
}

.message.bot {
  justify-content: flex-start;
}

.bubble {
  max-width: 70%;
  padding: 12px 16px;
  border-radius: 20px;
  font-size: 16px;
  line-height: 1.4;
  word-wrap: break-word;
}

.bubble.user {
  background: #007AFF;
  color: #fff;
  border-bottom-right-radius: 6px;
}

.bubble.bot {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  border-bottom-left-radius: 6px;
}

.message-time {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.5);
  margin-top: 4px;
  text-align: center;
}

/* Typing Indicator */
.typing {
  display: none;
  align-items: center;
  margin-bottom: 12px;
}

.typing-bubble {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 20px;
  padding: 12px 16px;
  border-bottom-left-radius: 6px;
}

.typing-dots {
  display: flex;
  gap: 4px;
}

.typing-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.6);
  animation: typing 1.4s infinite;
}

.typing-dot:nth-child(2) { animation-delay: 0.2s; }
.typing-dot:nth-child(3) { animation-delay: 0.4s; }

/* Input Area */
.input-area {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(20px);
  padding: 12px 16px 34px 16px;
  border-top: 0.5px solid rgba(255, 255, 255, 0.1);
}

.input-container {
  display: flex;
  align-items: flex-end;
  gap: 8px;
  max-width: 100%;
}

.text-input-wrapper {
  flex: 1;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 20px;
  display: flex;
  align-items: center;
  min-height: 40px;
  padding: 0 16px;
}

.text-input {
  flex: 1;
  background: transparent;
  border: none;
  outline: none;
  color: #fff;
  font-size: 16px;
  padding: 10px 0;
  resize: none;
  max-height: 100px;
}

.text-input::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.input-buttons {
  display: flex;
  gap: 8px;
  align-items: center;
}

.btn {
  width: 40px;
  height: 40px;
  border-radius: 20px;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.btn-mic {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
}

.btn-mic:hover {
  background: rgba(255, 255, 255, 0.2);
}

.btn-mic.recording {
  background: #FF3B30;
  animation: pulse 1s infinite;
}

.btn-send {
  background: #007AFF;
  color: #fff;
}

.btn-send:hover {
  background: #0056CC;
}

.btn-send:disabled {
  background: rgba(255, 255, 255, 0.1);
  color: rgba(255, 255, 255, 0.3);
  cursor: not-allowed;
}

.btn-stop {
  background: #FF3B30;
  color: #fff;
}

.btn-stop:hover {
  background: #D70015;
}

.btn-speaker {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
}

.btn-speaker:hover {
  background: rgba(255, 255, 255, 0.2);
}

.btn-speaker.muted {
  background: rgba(255, 59, 48, 0.2);
  color: #FF3B30;
}

/* Voice Mode Styles */
.voice-mode-container {
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  text-align: center;
  padding: 20px;
}

.voice-status {
  font-size: 18px;
  margin-bottom: 30px;
  color: rgba(255, 255, 255, 0.8);
}

.voice-controls {
  display: flex;
  gap: 20px;
}

.voice-btn {
  width: 80px;
  height: 80px;
  border-radius: 40px;
  border: none;
  font-size: 24px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.voice-btn-primary {
  background: #007AFF;
  color: #fff;
}

.voice-btn-primary:hover {
  background: #0056CC;
  transform: scale(1.05);
}

.voice-btn-stop {
  background: #FF3B30;
  color: #fff;
}

.voice-btn-stop:hover {
  background: #D70015;
  transform: scale(1.05);
}

/* Animations */
@keyframes typing {
  0%, 60%, 100% { opacity: 0.3; transform: scale(1); }
  30% { opacity: 1; transform: scale(1.2); }
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

/* Scrollbar */
.chat-container::-webkit-scrollbar {
  width: 2px;
}

.chat-container::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 1px;
}

.chat-container::-webkit-scrollbar-track {
  background: transparent;
}

/* Mobile Adjustments */
@media (max-width: 768px) {
  .bubble {
    max-width: 85%;
    font-size: 16px;
  }
  
  .mode-pills {
    padding: 1px;
  }
  
  .mode-pill {
    padding: 6px 12px;
    font-size: 13px;
  }
  
  .input-area {
    padding: 10px 12px 30px 12px;
  }
}
</style>
</head>
<body>

<!-- Header -->
<div class="header">
  <h1>Aina</h1>
</div>

<!-- Mode Selector -->
<div class="mode-selector">
  <div class="mode-pills">
    <button class="mode-pill active" data-mode="chat">üí¨ Chat</button>
    <button class="mode-pill" data-mode="voice">üéôÔ∏è Voice</button>
    <button class="mode-pill" data-mode="continuous">üîÑ Continuous</button>
  </div>
</div>

<!-- Chat Container -->
<div class="chat-container" id="chatContainer">
  <div class="welcome">
    <h2>Welcome to Aina</h2>
    <p>Your intelligent assistant is ready to help</p>
  </div>
</div>

<!-- Typing Indicator -->
<div class="typing" id="typingIndicator">
  <div class="typing-bubble">
    <div class="typing-dots">
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
    </div>
  </div>
</div>

<!-- Input Area -->
<div class="input-area" id="inputArea">
  <div class="input-container">
    <div class="text-input-wrapper">
      <textarea 
        class="text-input" 
        id="textInput" 
        placeholder="Message" 
        rows="1"
      ></textarea>
    </div>
    <div class="input-buttons">
      <button class="btn btn-mic" id="micBtn">üé§</button>
      <button class="btn btn-speaker" id="speakerBtn">üîä</button>
      <button class="btn btn-send" id="sendBtn">‚û§</button>
      <button class="btn btn-stop" id="stopBtn">‚èπ</button>
    </div>
  </div>
</div>

<!-- Voice Mode Container -->
<div class="voice-mode-container" id="voiceModeContainer">
  <div class="voice-status" id="voiceStatus">Tap to start listening</div>
  <div class="voice-controls">
    <button class="voice-btn voice-btn-primary" id="voiceStartBtn">üé§</button>
    <button class="voice-btn voice-btn-stop" id="voiceStopBtn">‚èπ</button>
  </div>
</div>

<script>
// Auto-detect deployment environment
let apiBase = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
  ? 'http://localhost:8000' 
  : 'https://voice-assistant-program.onrender.com';
let speechEnabled = true;
let mic = null;
let utter = null;
let audioUnlocked = false;
let currentMode = 'chat';
let chatMicActive = false;
let isProcessing = false;
let continuousActive = false;

// DOM Elements
const chatContainer = document.getElementById('chatContainer');
const textInput = document.getElementById('textInput');
const micBtn = document.getElementById('micBtn');
const speakerBtn = document.getElementById('speakerBtn');
const sendBtn = document.getElementById('sendBtn');
const stopBtn = document.getElementById('stopBtn');
const typingIndicator = document.getElementById('typingIndicator');
const inputArea = document.getElementById('inputArea');
const voiceModeContainer = document.getElementById('voiceModeContainer');
const voiceStatus = document.getElementById('voiceStatus');
const voiceStartBtn = document.getElementById('voiceStartBtn');
const voiceStopBtn = document.getElementById('voiceStopBtn');

// Initialize and check API connectivity
document.addEventListener('DOMContentLoaded', async function() {
  // Mode switching
  document.querySelectorAll('.mode-pill').forEach(pill => {
    pill.addEventListener('click', () => switchMode(pill.dataset.mode));
  });
  
  // Input handlers
  textInput.addEventListener('input', adjustTextareaHeight);
  textInput.addEventListener('keydown', handleTextInputKeydown);
  
  // Button handlers
  micBtn.addEventListener('click', toggleChatMic);
  speakerBtn.addEventListener('click', toggleSpeech);
  sendBtn.addEventListener('click', sendTextMessage);
  stopBtn.addEventListener('click', stopAll);
  voiceStartBtn.addEventListener('click', startVoice);
  voiceStopBtn.addEventListener('click', stopAll);
  
  // Audio unlock for iOS
  document.body.addEventListener('click', unlockAudio, { once: true });
  
  updateSpeakerButton();
  
  // Check API connectivity
  await checkApiConnectivity();
});

async function checkApiConnectivity() {
  try {
    console.log('Checking API connectivity at:', apiBase);
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);
    
    const response = await fetch(`${apiBase}/health`, { 
      method: 'GET',
      signal: controller.signal,
      headers: {
        'Accept': 'application/json',
        'Cache-Control': 'no-cache'
      }
    });
    
    clearTimeout(timeoutId);
    
    if (response.ok) {
      const data = await response.json();
      console.log('‚úÖ API connected successfully:', data);
      updateConnectionStatus(true);
    } else {
      throw new Error(`API health check failed: ${response.status}`);
    }
  } catch (error) {
    console.error('‚ùå API connectivity failed:', error);
    updateConnectionStatus(false);
    
    // Try fallback URLs if main fails
    await tryFallbackUrls();
  }
}

async function tryFallbackUrls() {
  const fallbackUrls = [
    'https://voice-assistant-program.onrender.com',
    'http://localhost:8000'
  ].filter(url => url !== apiBase);
  
  for (const url of fallbackUrls) {
    try {
      console.log('Trying fallback URL:', url);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3000);
      
      const response = await fetch(`${url}/health`, { 
        method: 'GET',
        signal: controller.signal,
        headers: {
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        }
      });
      
      clearTimeout(timeoutId);
      
      if (response.ok) {
        console.log('‚úÖ Fallback API connected:', url);
        apiBase = url;
        updateConnectionStatus(true);
        return;
      }
    } catch (error) {
      console.log('‚ùå Fallback failed for:', url, error.message);
    }
  }
  
  console.error('‚ùå All API endpoints failed');
}

function updateConnectionStatus(connected) {
  const welcome = chatContainer.querySelector('.welcome');
  if (welcome) {
    const statusIndicator = welcome.querySelector('.connection-status') || document.createElement('div');
    statusIndicator.className = 'connection-status';
    statusIndicator.style.cssText = `
      margin-top: 15px;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      display: inline-block;
      ${connected 
        ? 'background: rgba(52, 199, 89, 0.2); color: #34c759; border: 1px solid rgba(52, 199, 89, 0.3);' 
        : 'background: rgba(255, 59, 48, 0.2); color: #ff3b30; border: 1px solid rgba(255, 59, 48, 0.3);'
      }
    `;
    statusIndicator.textContent = connected ? 'üü¢ Connected' : 'üî¥ Connection Failed';
    
    if (!welcome.querySelector('.connection-status')) {
      welcome.appendChild(statusIndicator);
    }
  }
}

function switchMode(mode) {
  currentMode = mode;
  stopAll();
  
  // Update active pill
  document.querySelectorAll('.mode-pill').forEach(pill => {
    pill.classList.toggle('active', pill.dataset.mode === mode);
  });
  
  // Show/hide appropriate containers
  if (mode === 'chat') {
    chatContainer.style.display = 'block';
    inputArea.style.display = 'block';
    voiceModeContainer.style.display = 'none';
  } else {
    chatContainer.style.display = 'none';
    inputArea.style.display = 'none';
    voiceModeContainer.style.display = 'flex';
    
    if (mode === 'continuous') {
      setTimeout(startContinuousVoice, 500);
    }
  }
}

function adjustTextareaHeight() {
  textInput.style.height = 'auto';
  textInput.style.height = Math.min(textInput.scrollHeight, 100) + 'px';
}

function handleTextInputKeydown(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendTextMessage();
  }
}

function addMessage(text, sender, type = 'text', source = '') {
  const welcome = chatContainer.querySelector('.welcome');
  if (welcome) welcome.style.display = 'none';
  
  const message = document.createElement('div');
  message.className = `message ${sender}`;
  
  const bubble = document.createElement('div');
  bubble.className = `bubble ${sender}`;
  bubble.textContent = text;
  
  const time = document.createElement('div');
  time.className = 'message-time';
  time.textContent = new Date().toLocaleTimeString([], { 
    hour: '2-digit', 
    minute: '2-digit' 
  });
  
  bubble.appendChild(time);
  message.appendChild(bubble);
  chatContainer.appendChild(message);
  
  chatContainer.scrollTop = chatContainer.scrollHeight;
}

function showTypingIndicator() {
  chatContainer.appendChild(typingIndicator);
  typingIndicator.style.display = 'flex';
  chatContainer.scrollTop = chatContainer.scrollHeight;
}

function hideTypingIndicator() {
  typingIndicator.style.display = 'none';
}

function toggleChatMic() {
  if (chatMicActive) {
    stopChatMic();
  } else {
    startChatMic();
  }
}

function startChatMic() {
  if (!('webkitSpeechRecognition' in window)) {
    addMessage('Voice recognition not supported in this browser', 'bot', 'error');
    return;
  }
  
  if (speechSynthesis.speaking) speechSynthesis.cancel();
  
  micBtn.classList.add('recording');
  micBtn.textContent = 'üî¥';
  chatMicActive = true;
  
  mic = new webkitSpeechRecognition();
  mic.lang = 'en-US';
  mic.continuous = false;
  mic.interimResults = false;
  
  mic.onresult = (e) => {
    const transcript = e.results[0][0].transcript;
    textInput.value = transcript;
    adjustTextareaHeight();
    stopChatMic();
    sendTextMessage();
  };
  
  mic.onerror = (e) => {
    console.error('Speech recognition error:', e);
    stopChatMic();
  };
  
  mic.onend = () => {
    stopChatMic();
  };
  
  mic.start();
}

function stopChatMic() {
  micBtn.classList.remove('recording');
  micBtn.textContent = 'üé§';
  chatMicActive = false;
  
  if (mic && mic.abort) {
    mic.abort();
    mic = null;
  }
}

function toggleSpeech() {
  speechEnabled = !speechEnabled;
  updateSpeakerButton();
  addMessage(`Speech ${speechEnabled ? 'enabled' : 'disabled'}`, 'bot', 'status');
}

function updateSpeakerButton() {
  speakerBtn.classList.toggle('muted', !speechEnabled);
  speakerBtn.textContent = speechEnabled ? 'üîä' : 'üîá';
}

async function sendTextMessage() {
  const text = textInput.value.trim();
  if (!text || isProcessing) return;
  
  isProcessing = true;
  stopAll();
  
  addMessage(text, 'user');
  textInput.value = '';
  adjustTextareaHeight();
  
  showTypingIndicator();
  
  try {
    console.log('Sending request to:', `${apiBase}/ask?question=${encodeURIComponent(text)}`);
    
    // Add timeout and retry logic
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
    
    const response = await fetch(`${apiBase}/ask?question=${encodeURIComponent(text)}`, {
      signal: controller.signal,
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'Cache-Control': 'no-cache'
      }
    });
    
    clearTimeout(timeoutId);
    console.log('Response status:', response.status);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('Response data:', data);
    
    hideTypingIndicator();
    
    const answerText = data.answer || "I didn't receive a proper response.";
    addMessage(answerText, 'bot', data.type || 'text', data.source || '');
    
    if (audioUnlocked && speechEnabled) {
      speak(answerText);
    }
    
  } catch (error) {
    hideTypingIndicator();
    console.error('Error:', error);
    
    let errorMessage = "I'm having trouble connecting right now.";
    if (error.name === 'AbortError') {
      errorMessage = "Request timed out. Please try again.";
    } else if (error.message.includes('Failed to fetch')) {
      errorMessage = "Network connection failed. Check your internet connection.";
    } else if (error.message.includes('HTTP error')) {
      errorMessage = `Server error: ${error.message}`;
    }
    
    addMessage(errorMessage, 'bot', 'error');
    
    // Try to reconnect
    setTimeout(checkApiConnectivity, 2000);
  }
  
  isProcessing = false;
}

function startVoice() {
  if (!('webkitSpeechRecognition' in window)) {
    voiceStatus.textContent = 'Voice recognition not supported in this browser';
    return;
  }
  
  if (speechSynthesis.speaking) speechSynthesis.cancel();
  if (mic) mic.stop();
  
  voiceStatus.textContent = 'Listening...';
  
  mic = new webkitSpeechRecognition();
  mic.lang = 'en-US';
  mic.continuous = false;
  mic.interimResults = false;
  
  mic.onresult = (e) => {
    const transcript = e.results[0][0].transcript;
    voiceStatus.textContent = `You said: "${transcript}"`;
    processVoiceMessage(transcript);
  };
  
  mic.onerror = (e) => {
    console.error('Speech recognition error:', e);
    voiceStatus.textContent = 'Error occurred. Try again.';
  };
  
  mic.onend = () => {
    if (currentMode !== 'continuous') {
      voiceStatus.textContent = 'Tap to start listening';
    }
    mic = null;
  };
  
  mic.start();
}

function startContinuousVoice() {
  if (!('webkitSpeechRecognition' in window)) {
    voiceStatus.textContent = 'Voice recognition not supported in this browser';
    return;
  }
  
  if (mic) mic.stop();
  
  voiceStatus.textContent = 'Continuous listening active...';
  continuousActive = true;
  
  mic = new webkitSpeechRecognition();
  mic.lang = 'en-US';
  mic.continuous = true;
  mic.interimResults = false;
  
  mic.onresult = (e) => {
    for (let i = e.resultIndex; i < e.results.length; i++) {
      if (e.results[i].isFinal) {
        const transcript = e.results[i][0].transcript;
        voiceStatus.textContent = `Processing: "${transcript}"`;
        processVoiceMessage(transcript);
      }
    }
  };
  
  mic.onerror = (e) => {
    console.error('Continuous speech error:', e);
    if (currentMode === 'continuous') {
      setTimeout(() => {
        if (continuousActive) startContinuousVoice();
      }, 1000);
    }
  };
  
  mic.onend = () => {
    if (currentMode === 'continuous' && continuousActive) {
      setTimeout(() => {
        if (continuousActive) {
          mic.start();
          voiceStatus.textContent = 'Continuous listening active...';
        }
      }, 1000);
    } else {
      mic = null;
    }
  };
  
  mic.start();
}

async function processVoiceMessage(text) {
  if (speechSynthesis.speaking) speechSynthesis.cancel();
  if (isProcessing) return;
  
  isProcessing = true;
  
  try {
    console.log('Processing voice message:', text);
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000);
    
    const response = await fetch(`${apiBase}/ask?question=${encodeURIComponent(text)}`, {
      signal: controller.signal,
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'Cache-Control': 'no-cache'
      }
    });
    
    clearTimeout(timeoutId);
    console.log('Voice response status:', response.status);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('Voice response data:', data);
    
    const answerText = data.answer || "I didn't receive a proper response.";
    
    if (currentMode !== 'chat') {
      voiceStatus.textContent = answerText.substring(0, 100) + (answerText.length > 100 ? '...' : '');
    }
    
    if (audioUnlocked && speechEnabled) {
      speak(answerText);
    }
    
  } catch (error) {
    console.error('Voice processing error:', error);
    let errorMessage = "Connection error occurred";
    if (error.name === 'AbortError') {
      errorMessage = "Request timed out";
    }
    voiceStatus.textContent = errorMessage;
  }
  
  isProcessing = false;
}

function speak(text) {
  if (speechSynthesis.speaking) speechSynthesis.cancel();
  
  utter = new SpeechSynthesisUtterance(text);
  utter.rate = 0.9;
  utter.pitch = 1;
  utter.volume = 0.8;
  
  const voices = speechSynthesis.getVoices();
  const preferredVoice = voices.find(voice => 
    voice.name.includes('Google') || 
    voice.name.includes('Alex') || 
    voice.name.includes('Samantha')
  );
  if (preferredVoice) utter.voice = preferredVoice;
  
  speechSynthesis.speak(utter);
}

function stopAll() {
  // Stop speech recognition
  if (mic) {
    mic.onresult = null;
    mic.onerror = null;
    mic.onend = null;
    mic.stop();
    mic = null;
  }
  
  // Stop chat mic
  stopChatMic();
  
  // Stop speech synthesis
  if (speechSynthesis.speaking) speechSynthesis.cancel();
  
  // Stop continuous mode
  continuousActive = false;
  
  // Hide typing indicator
  hideTypingIndicator();
  
  // Reset processing flag
  isProcessing = false;
  
  // Update voice status
  if (currentMode !== 'chat') {
    voiceStatus.textContent = 'Tap to start listening';
  }
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    stopAll();
  }
});
</script>

</body>
</html>
